/**
 * Functions for getting turns by topic ID or path
 */

// Import the message type constants
const MESSAGE_TYPE = {
  USER: 1,
  LLM: 2
};

/**
 * Gets all turns for a topic using its numeric ID
 * @param {number} topicId - The numeric ID of the topic
 * @param {Pool} pool - The PostgreSQL connection pool
 * @param {number} [limit=100] - Maximum number of turns to return
 * @returns {Promise<Array>} Array of topic turns
 */
export async function getTurnsByTopicId(topicId, pool, limit = 100) {
  try {
    console.log('Executing getTurnsByTopicId with:', { topicId, limit });
    
    // Validate that we have a proper pool object
    if (!pool || typeof pool.query !== 'function') {
      console.error('Invalid pool object provided to getTurnsByTopicId:', pool);
      throw new Error('Invalid database pool object');
    }
    
    // Use the grp_topic_avatar_turns_with_names view to get participant and LLM names
    const result = await pool.query(
      `SELECT id, topic_id, avatar_id, content_text, 
              message_type_id, turn_kind_id, created_at, turn_index,
              llm_id, participant_id, participant_name,
              llm_name
       FROM grp_topic_avatar_turns_with_names
       WHERE topic_id = $1
       ORDER BY turn_index ASC
       LIMIT $2`,
      [topicId, limit]
    );
    
    console.log(`Found ${result.rows.length} messages for topic ID ${topicId}`);
    
    return result.rows.map(row => ({
      id: row.id,
      topicId: row.topic_id,
      avatarId: row.avatar_id,
      content: row.content_text,
      isUser: row.message_type_id === MESSAGE_TYPE.USER,
      turnKindId: row.turn_kind_id,
      createdAt: row.created_at,
      turnIndex: row.turn_index,
      llmId: row.llm_id,
      participantId: row.participant_id,
      participantName: row.participant_name,
      llmName: row.llm_name
    }));
  } catch (error) {
    console.error('Error getting turns by topic ID:', error);
    // Return empty array instead of throwing an error to avoid 500 responses
    return [];
  }
}

/**
 * Gets all turns for a topic path
 * @param {string} topicPath - The path of the topic
 * @param {Pool} pool - The PostgreSQL connection pool
 * @param {number} [limit=100] - Maximum number of turns to return
 * @returns {Promise<Array>} Array of topic turns
 */
export async function getTurnsByTopicPath(topicPath, pool, limit = 100) {
  try {
    console.log('Getting topic ID for path:', topicPath);
    
    // First get the topic ID from the path
    const topicResult = await pool.query(
      'SELECT id FROM grp_topics WHERE path = $1',
      [topicPath]
    );
    
    if (topicResult.rows.length === 0) {
      console.warn(`No topic found with path: ${topicPath}`);
      return [];
    }
    
    const topicId = topicResult.rows[0].id;
    console.log(`Found topic ID ${topicId} for path ${topicPath}`);
    
    // Then get the turns using the ID
    return getTurnsByTopicId(topicId, pool, limit);
  } catch (error) {
    console.error('Error getting turns by topic path:', error);
    return [];
  }
}

/**
 * Gets the next turn index for a topic
 * @param {number} topicId - The numeric ID of the topic
 * @param {Pool} pool - The PostgreSQL connection pool
 * @returns {Promise<number>} The next turn index
 */
export async function getNextTurnIndex(topicId, pool) {
  try {
    const result = await pool.query(
      'SELECT COALESCE(MAX(turn_index), 0) + 1 as next_index FROM grp_topic_avatar_turns WHERE topic_id = $1',
      [topicId]
    );
    return result.rows[0].next_index;
  } catch (error) {
    console.error('Error getting next turn index:', error);
    throw error;
  }
}

export { MESSAGE_TYPE };
